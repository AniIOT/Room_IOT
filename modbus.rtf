{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang16393{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.17134}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang9 /*\par
 * modbus.c\par
 *\par
 *  Created on: 23-Jul-2018\par
 *      Author: vervetronics\par
 */\par
\par
#include<stdio.h>\par
#include<string.h>\par
#include"modbus.h"\par
#include"hal_uart.h"\par
#include"Utils.h"\par
#include"stm32f0xx.h"\par
#include"db_sensor.h"\par
\par
//void Delay_mS(UINT16 mTime);\par
//UCHAR8 ars[10];\par
//UCHAR8 RXBuff[50] =\{0\};\par
//UCHAR8  Packet[8]  = \{0\};  // the value shown\par
//char Packet2[8]=\{0x0b,0x03,0x17,0x71,0x00,0x01,0xd1,0xf\};\par
modbus_t sVfdModbusConfig;\par
\par
// TODO: PT: Set Slave Address\par
UCHAR8 u8ModbusMotorHoistVfd_SlaveAdd = 0xb;\tab\tab    //Slave Address between 1 to 247\par
UCHAR8 u8ModbusSensorVib_SlaveAdd = 0x55;\tab\tab    //Slave Address between 1 to 247\par
\par
// Function codes for commands\par
#define MODBUS_READWRITEMUL_FUNCCODE \tab 0x17\par
#define MODBUS_READMUL_FUNCCODE \tab\tab\tab 0x03\par
#define MODBUS_SENSVI_READ_FUNCCODE \tab\tab 0xAA\par
\par
// Macros for Read Multiple\par
#define MODBUS_READWRITEMUL_MAXPL 0x8\par
\par
#define MODBUS_SENSVIB_MAXRESP_PAYLOAD_BYTES\tab\tab\tab 0x08\par
#define MODBUS_SLAVEADD_LENGHT_BYTES\tab\tab\tab\tab\tab\tab 0x01 //bytes\par
#define MODBUS_CRCSIZE_BYTES\tab\tab\tab\tab\tab\tab 0x02 //bytes\par
\par
UINT16 modbus_CalcCRC(UCHAR8 *packet, UINT16 packetlength)\par
\{\par
\tab\{\par
\tab\tab UINT16 crc = 0xffff,poly = 0xA001,i=0,j=0;\par
\tab\tab for(i=0;i<packetlength;i++)\par
\tab\tab\{\par
\tab\tab\tab crc^= packet[i];\par
\tab\tab\tab for(j=0;j<8;j++)\par
\tab\tab\tab\{\par
\tab\tab\tab\tab if(crc & 0x01)\par
\tab\tab\tab\tab\{\par
\tab\tab\tab\tab\tab crc >>= 1;\par
\tab\tab\tab\tab\tab crc ^= poly;\par
\tab\tab\tab\tab\}\par
\tab\tab\tab\tab else\par
\tab\tab\tab\tab\tab crc >>= 1;\par
\tab\tab\tab\}\par
\tab\tab\}\par
\tab\tab return (crc);\par
\tab\}\par
\}\par
/*\par
void BuildPacketForRegisterWrite(UCHAR8 *packet)\par
\{\par
\tab packet[0] = sVfdModbusConfig.SlaveAdd;\par
\tab packet[1] = sVfdModbusConfig.FunctionCode;\par
\tab packet[2] = sVfdModbusConfig.DataRegisterAddHigh;\par
\tab packet[3] = sVfdModbusConfig.DataRegisterAddLow;\par
\tab packet[4] = sVfdModbusConfig.BytesToBeReadHigh;\par
\tab packet[5] = sVfdModbusConfig.BytesToBeReadLow;\par
\tab sVfdModbusConfig.CRC1 = modbus_CalcCRC(packet,6);\par
\tab packet[6] = sVfdModbusConfig.CRC1 & 0xFF;   // lower byte first\par
\tab packet[7] = sVfdModbusConfig.CRC1 >> 8;\par
\}\par
\par
void BuildPacketForRegisterRead(UCHAR8 *packet)\par
\{\par
\tab packet[0] = sVfdModbusConfig.SlaveAdd;\par
\tab packet[1] = sVfdModbusConfig.FunctionCode;\par
\tab packet[2] = sVfdModbusConfig.DataRegisterAddHigh;\par
\tab packet[3] = sVfdModbusConfig.DataRegisterAddLow;\par
\tab packet[4] = sVfdModbusConfig.BytesToBeReadHigh;\par
\tab packet[5] = sVfdModbusConfig.BytesToBeReadLow;\par
\tab sVfdModbusConfig.CRC1 = modbus_CalcCRC(Packet,6);\par
\tab packet[6] = sVfdModbusConfig.CRC1 & 0xFF;\par
\tab packet[7] = sVfdModbusConfig.CRC1 >> 8;\par
\}\par
\par
void ReadStatusOfCoil(UCHAR8 *packet)\par
\{\par
\tab packet[0]=sVfdModbusConfig.SlaveAdd;\par
\tab packet[1]=sVfdModbusConfig.FunctionCode;\par
\tab packet[2]=sVfdModbusConfig.CoilHigh;\par
\tab packet[3]=sVfdModbusConfig.CoilLow;\par
\tab sVfdModbusConfig.CRC1=modbus_CalcCRC(Packet,4);\par
\tab packet[4] = sVfdModbusConfig.CRC1 & 0xFF;\par
\tab packet[5] = sVfdModbusConfig.CRC1 >> 8;\par
\}\par
\par
\par
void modbus_Init(UCHAR8 SlaveAdd,UCHAR8 FunctionCode,UINT16 RegisterAdd,UINT16 RWLength)\par
\{\par
\tab sVfdModbusConfig.SlaveAdd = SlaveAdd;\tab\tab\tab // must be unique on bus\par
\tab sVfdModbusConfig.FunctionCode = FunctionCode;    // refer Modbus.h file\par
\tab sVfdModbusConfig.DataRegisterAddHigh = ((RegisterAdd>>8)&0xff);   //High Byte of address\par
\tab sVfdModbusConfig.DataRegisterAddLow = RegisterAdd&0xff;\tab   //low byte of address\par
\tab sVfdModbusConfig.BytesToBeReadHigh = ((RWLength>>8)&0xff);\par
\tab sVfdModbusConfig.BytesToBeReadLow = RWLength & 0xff;\par
\tab //\tab modbus1.CoilHigh=0x00;\par
\tab //\tab modbus1.CoilLow=0x02;\par
\tab //BuildPacketForRegisterRead(Packet);\par
\par
\tab //hal_uart_Tx(2,Packet,8);\par
\tab modbus_ResetSensorData();\par
\tab //hal_uart_Rx(2,50,&RXBuff);\par
\par
\}*/\par
\par
void modbus_ReadMultipleReq(UINT16 u16StartAdd,UINT16 u16Quant)\par
\{\par
\tab UCHAR8 u8TxBuffer[MODBUS_READWRITEMUL_MAXPL]=\{0\};\par
\tab UCHAR8 i=0;\par
\tab UINT16 u16CRC=0;\par
\par
\tab u8TxBuffer[i++] = u8ModbusMotorHoistVfd_SlaveAdd;\par
\tab u8TxBuffer[i++] = MODBUS_READMUL_FUNCCODE;\par
\tab u8TxBuffer[i++] = ((u16StartAdd & GLOBALS_BITMASK_HIGHBYTE)>>(GLOBALS_BITMASK_SHIFTHIGHBYTE2LOW));\par
\tab u8TxBuffer[i++] = u16StartAdd & GLOBALS_BITMASK_LOWBYTE;\par
\tab u8TxBuffer[i++] = ((u16Quant & GLOBALS_BITMASK_HIGHBYTE)>>(GLOBALS_BITMASK_SHIFTHIGHBYTE2LOW));\par
\tab u8TxBuffer[i++] = u16Quant & GLOBALS_BITMASK_LOWBYTE;\par
\tab u16CRC = modbus_CalcCRC(u8TxBuffer,i);\par
\tab u8TxBuffer[i++] = u16CRC & 0x00FF;\par
\tab u8TxBuffer[i++] = ((u16CRC & 0xFF00)>>0x8);\par
\par
\tab hal_uart_Tx(haluart_modbus,u8TxBuffer,MODBUS_READWRITEMUL_MAXPL);\par
\}\par
\par
void modbus_ReadMultipleResp(UCHAR8 SlaveAdd,UCHAR8 FunctionCode,UINT16 RegisterAdd,UINT16 RWLength)\par
\{\par
\par
\}\par
\par
void modbus_ReadCommScnResp(UCHAR8 SlaveAdd,UCHAR8 FunctionCode,UINT16 RegisterAdd,UINT16 RWLength)\par
\{\par
\par
\}\par
void modbus_ResetSensorData()\par
\{\par
\par
\}\par
\par
void modbus_SetVfdSlaveAddress(UCHAR8 u8SlaveAddress)\par
\{\par
\tab u8ModbusMotorHoistVfd_SlaveAdd = u8SlaveAddress;\par
\par
\}\par
\par
void modbus_ReadHistoryReq()\par
\{\par
\tab modbus_ReadMultipleReq(MODBUS_HISTPARARM_FAULTCODELAST,35);\par
\}\par
\par
void modbus_ReadActualReq()\par
\{\par
//\tab modbus_ReadMultipleReq(0x1771,2);\par
\tab modbus_ReadMultipleReq(MODBUS_ACTUALPARAM_MOTORCURRENT,(MODBUS_ACTUALPARAM_MOTORPOWER-MODBUS_ACTUALPARAM_MOTORCURRENT+1));\par
\}\par
\par
//To be called every 250ms for actual data in VFD\par
BOOL8 modbus_ReadHistoryResp()\par
\{\par
\tab BOOL8 bStatus=0;\par
\tab static UCHAR8 *pRxbuffer=0;\par
\tab UCHAR8 u8ByteRead = 0;\par
\tab UINT16 u16ByteRead = 0;\par
\tab\par
\tab //Check if the complete response is received.\par
\tab if (hal_uart_RxIntGetNoofRxBytes(haluart_modbus)>=((MODBUS_HISTPARARM_MAINSVOLT - MODBUS_HISTPARARM_FAULTCODELAST+1)*2))\par
\tab\{\par
\tab\tab // TODO: PT: handle negative response in MODBUS UART\par
\tab\tab bStatus = hal_uart_RxInt(haluart_modbus,&pRxbuffer);\par
\tab\}\par
\tab else\par
\tab\{\par
\tab\tab hal_uart_clearRxbuff(haluart_modbus);\par
\tab\tab return 0;\par
\tab\}\par
\par
\tab if (bStatus == 0)\par
\tab\{\par
\tab\tab hal_uart_clearRxbuff(haluart_modbus);\par
\tab\tab return 0;\par
\tab\}\par
\tab //Get Slave addres from buffer.\par
\tab u8ByteRead = *pRxbuffer++;\par
\tab if (u8ByteRead !=u8ModbusMotorHoistVfd_SlaveAdd)\par
\tab\{\par
\tab\tab hal_uart_clearRxbuff(haluart_modbus);\par
\tab\tab return 0;\par
\tab\}\par
\par
\tab //Read Function Code\par
\tab u8ByteRead = *pRxbuffer++;\par
\tab if (u8ByteRead !=MODBUS_READMUL_FUNCCODE)\par
\tab\{\par
\tab\tab hal_uart_clearRxbuff(haluart_modbus);\par
\tab\tab return 0;\par
\tab\}\par
\par
\tab //pRxbuffer++;  // incrementing the ptr to eliminate Rx byte count\par
\tab //Read the fault code\par
\tab u16ByteRead = ((*pRxbuffer++)<<8);\par
\tab u16ByteRead += *pRxbuffer++;\par
\tab dbSensor_SetNode(eModBusFaultCode,u16ByteRead);\par
\par
\tab //Read the Motor Current\par
\tab pRxbuffer = pRxbuffer + (MODBUS_HISTPARARM_MOTORCUR - MODBUS_HISTPARARM_FAULTCODELAST+1)*2;\par
\tab u16ByteRead = ((*pRxbuffer++)<<8);\par
\tab u16ByteRead += *pRxbuffer++;\par
\tab dbSensor_SetNode(eModBusFaultMotorCur,u16ByteRead);\par
\par
\tab //Read the Mains Voltage\par
\tab pRxbuffer = pRxbuffer + (MODBUS_HISTPARARM_MAINSVOLT - MODBUS_HISTPARARM_MOTORCUR+1)*2;\par
\tab u16ByteRead = ((*pRxbuffer++)<<8);\par
\tab u16ByteRead += *pRxbuffer++;\par
\tab dbSensor_SetNode(eModBusFaultMainsVolt,u16ByteRead);\par
\par
\tab hal_uart_clearRxbuff(haluart_modbus);\par
\tab debugprintf((UCHAR8*)("VFD-HIS-RESP\\r\\n"));\par
\par
\tab return 1;\par
\par
\}\par
\par
//To be called every 250ms for actual data in VFD\par
BOOL8 modbus_ReadActualResp()\par
\{\par
\tab BOOL8 bStatus;\par
\tab static UCHAR8 *pRxbuffer=0;\par
\tab UCHAR8 u8ByteRead =0;\par
\tab UINT16 u16ByteRead =0;\par
\tab\par
\tab //Check if the complete response is received.\par
\tab if (hal_uart_RxIntGetNoofRxBytes(haluart_modbus)>=((MODBUS_ACTUALPARAM_MOTORPOWER- MODBUS_ACTUALPARAM_MOTORCURRENT +1)*2))\par
\tab\{\par
\tab\tab // TODO: PT: handle negative response in MODBUS UART\par
\tab\tab bStatus = hal_uart_RxInt(haluart_modbus,&pRxbuffer);\par
\tab\}\par
\tab else\par
\tab\{\par
\tab\tab hal_uart_clearRxbuff(haluart_modbus);\par
\tab\tab return 0;\par
\tab\}\par
\tab\par
\tab if (bStatus == 0)\par
\tab\{\par
\tab\tab hal_uart_clearRxbuff(haluart_modbus);\par
\tab\tab return 0;\par
\tab\}\par
\par
\tab //Parse the data from buffer.\par
\tab u8ByteRead = *pRxbuffer++;\par
\tab if (u8ByteRead !=u8ModbusMotorHoistVfd_SlaveAdd)\par
\tab\{\par
\tab\tab hal_uart_clearRxbuff(haluart_modbus);\par
\tab\tab return 0;\par
\tab\}\par
\par
\tab //Read Function Code\par
\tab u8ByteRead = *pRxbuffer++;\par
\tab if (u8ByteRead !=MODBUS_READMUL_FUNCCODE)\par
\tab\{\par
\tab\tab hal_uart_clearRxbuff(haluart_modbus);\par
\tab\tab return 0;\par
\tab\}\par
\par
\tab pRxbuffer++;// incrementing the ptr to eliminate Rx byte count\par
\par
\tab //Read the motor current\par
\tab u16ByteRead = ((*pRxbuffer++)<<8);\par
\tab u16ByteRead += (*pRxbuffer++);\par
\tab dbSensor_SetNode(eModBusMotorCur,u16ByteRead);\par
\par
\tab //Read the Motor Torque\par
\tab u16ByteRead = ((*pRxbuffer++)<<8);\par
\tab u16ByteRead += *pRxbuffer++;\par
\tab dbSensor_SetNode(eModBusMotorTorque,u16ByteRead);\par
\par
\tab //Read the Mains Voltage\par
\tab pRxbuffer+=2;\par
\tab u16ByteRead = ((*pRxbuffer++)<<8);\par
\tab u16ByteRead += *pRxbuffer++;\par
\tab dbSensor_SetNode(eModBusMainsVolt,u16ByteRead);\par
\par
\tab //Read the Motor Voltage\par
\tab u16ByteRead = ((*pRxbuffer++)<<8);\par
\tab u16ByteRead += *pRxbuffer++;\par
\tab dbSensor_SetNode(eModBusMotorVolt,u16ByteRead);\par
\par
\tab //Read the Drive State\par
\tab u16ByteRead = ((*pRxbuffer++)<<8);\par
\tab u16ByteRead += *pRxbuffer++;\par
\tab dbSensor_SetNode(eModBusMotorDriveThSt,u16ByteRead);\par
\par
\tab //Read the Motor Power\par
\tab pRxbuffer+=2;\par
\tab u16ByteRead = ((*pRxbuffer++)<<8);\par
\tab u16ByteRead += *pRxbuffer;\par
\tab dbSensor_SetNode(eModBusMotorPower,u16ByteRead);\par
\par
\tab hal_uart_clearRxbuff(haluart_modbus);\par
\par
\tab return 1;\par
\}\par
\par
BOOL8 modbus_ReadSensVibReq ()\par
\{\par
\tab UCHAR8 u8TxBuffer[MODBUS_READWRITEMUL_MAXPL]=\{0\};\par
\tab UCHAR8 i=0;\par
\tab UINT16 u16CRC=0;\par
\tab\par
\tab u8TxBuffer[i++] = u8ModbusSensorVib_SlaveAdd;\par
\tab u8TxBuffer[i++] = MODBUS_SENSVI_READ_FUNCCODE;\par
\tab u8TxBuffer[i++] = 0x00;\par
\tab u8TxBuffer[i++] = 0x00;\par
\tab u8TxBuffer[i++] = 0x00;\par
\tab u8TxBuffer[i++] = 0x00;\par
\tab u16CRC = modbus_CalcCRC(u8TxBuffer,i);\par
\tab u8TxBuffer[i++] = (u16CRC & 0x00FF);\par
\tab u8TxBuffer[i++] = ((u16CRC & 0xFF00)>>0x8);\par
\par
\tab hal_uart_Tx(haluart_modbus,u8TxBuffer,MODBUS_SENSVIB_MAXRESP_PAYLOAD_BYTES);\par
\par
\par
\tab return 1;\par
\}\par
\par
BOOL8 modbus_ReadSensVibResp ()\par
\{\par
\tab BOOL8 bStatus;\par
\tab static UCHAR8 *pRxbuffer=0;\par
\tab UCHAR8 u8ByteRead =0;\par
\tab UINT16 u16ByteRead =0;\par
\tab\par
\tab //Check if the complete response is received.\par
\tab if (hal_uart_RxIntGetNoofRxBytes(haluart_modbus)>=(MODBUS_SLAVEADD_LENGHT_BYTES +MODBUS_SENSVIB_MAXRESP_PAYLOAD_BYTES+MODBUS_CRCSIZE_BYTES))\par
\tab\{\par
\tab\tab // TODO: PT: handle negative response in MODBUS UART\par
\tab\tab bStatus = hal_uart_RxInt(haluart_modbus,&pRxbuffer);\par
\tab\}\par
\tab else\par
\tab\{\par
\tab\tab hal_uart_clearRxbuff(haluart_modbus);\par
\tab\tab return 0;\par
\tab\}\par
\tab\par
\tab if (bStatus == 0)\par
\tab\{\par
\tab\tab hal_uart_clearRxbuff(haluart_modbus);\par
\tab\tab return 0;\par
\tab\}\par
\par
\tab //Parse the data from buffer.\par
\tab u8ByteRead = *pRxbuffer++;\par
\tab if (u8ByteRead !=u8ModbusSensorVib_SlaveAdd)\par
\tab\{\par
\tab\tab hal_uart_clearRxbuff(haluart_modbus);\par
\tab\tab return 0;\par
\tab\}\par
\tab u8ByteRead = *pRxbuffer++;\par
\tab if (u8ByteRead !=MODBUS_SENSVI_READ_FUNCCODE)\par
\tab\{\par
\tab\tab hal_uart_clearRxbuff(haluart_modbus);\par
\tab\tab return 0;\par
\tab\}\par
\par
\tab //Read the motor Vibration X\par
\tab u16ByteRead = (*pRxbuffer++);\par
\tab u16ByteRead += ((*pRxbuffer++)<<8);\par
\tab dbSensor_SetNode(eMotorHoistVibX,u16ByteRead);\par
\par
\tab //Read the motor Vibration Y\par
\tab u16ByteRead = (*pRxbuffer++);\par
\tab u16ByteRead += ((*pRxbuffer++)<<8);\par
\tab dbSensor_SetNode(eMotorHoistVibY,u16ByteRead);\par
\par
\tab //Read the motor Vibration Z\par
\tab u16ByteRead = (*pRxbuffer++);\par
\tab u16ByteRead += ((*pRxbuffer++)<<8);\par
\tab dbSensor_SetNode(eMotorHoistVibZ,u16ByteRead);\par
\par
\tab //Read the Load Kg\par
\tab u16ByteRead = (*pRxbuffer++);\par
\tab u16ByteRead += ((*pRxbuffer++)<<8);\par
\tab dbSensor_SetNode(eLoadCell,u16ByteRead);\par
\par
\tab hal_uart_clearRxbuff(haluart_modbus);\par
\tab debugprintf((UCHAR8*)("ADD-VIB-RESP\\r\\n"));\par
\tab return 1;\par
\par
\}\par
\par
\par
}
 